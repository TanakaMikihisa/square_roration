<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>正方形の回転運動の可視化</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .control-group {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #495057;
        }
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .control-group .value {
            font-size: 14px;
            color: #6c757d;
            text-align: center;
        }
        .sync-control {
            background-color: #e8f5e8;
            border-color: #4caf50;
        }
        .sync-control label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
            color: #2e7d32;
        }
        .sync-control input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }
        .snap-control {
            background-color: #fff3e0;
            border-color: #ff9800;
        }
        .snap-control label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
            color: #e65100;
        }
        .snap-control input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }
        canvas {
            border: 2px solid #dee2e6;
            border-radius: 8px;
            display: block;
            margin: 0 auto;
            background-color: white;
        }
        .info {
            margin-top: 20px;
            padding: 15px;
            background-color: #e3f2fd;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }
        .info h3 {
            margin-top: 0;
            color: #1976d2;
        }
        .info p {
            margin: 5px 0;
            color: #424242;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>正方形の回転運動の可視化</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="r">r (正方形の半径):</label>
                <input type="range" id="r" min="0.5" max="3" step="0.1" value="1.5">
                <div class="value" id="r-value">1.5</div>
            </div>
            
            <div class="control-group">
                <label for="l">ℓ (点Iのx座標):</label>
                <input type="range" id="l" min="0.5" max="4" step="0.1" value="2">
                <div class="value" id="l-value">2.0</div>
            </div>
            
            <div class="control-group">
                <label for="theta">θ (点Iの回転角):</label>
                <input type="range" id="theta" min="0" max="6.28318" step="0.01" value="0">
                <div class="value" id="theta-value">0.00 rad (0.0°)</div>
            </div>
            
            <div class="control-group">
                <label for="phi">φ (正方形の回転角):</label>
                <input type="range" id="phi" min="0" max="6.28318" step="0.01" value="0">
                <div class="value" id="phi-value">0.00 rad (0.0°)</div>
            </div>
            
            <div class="control-group sync-control">
                <label>
                    <input type="checkbox" id="sync-toggle"> θとφを同期
                </label>
            </div>
            
            <div class="control-group" id="ratio-group" style="display: none;">
                <label for="ratio">φ/θ の比率:</label>
                <input type="range" id="ratio" min="-3" max="3" step="0.01" value="1">
                <div class="value" id="ratio-value">1.00</div>
            </div>
            
            
            <div class="control-group" style="background-color: #e8f5e8; border-color: #4caf50;">
                <button id="toggle-trajectory" style="width: 100%; padding: 10px; background-color: #4caf50; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; margin-bottom: 5px;">
                    軌跡を表示
                </button>
                <button id="clear-trajectory" style="width: 100%; padding: 10px; background-color: #ff9800; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">
                    軌跡をクリア
                </button>
            </div>
        </div>
        
        <canvas id="canvas" width="800" height="600"></canvas>
        
        <div class="info">
            <h3>問題の説明</h3>
            <p>• 点I(ℓ,0)が原点Oを中心として時計回りにθ回転</p>
            <p>• 正方形PQRSは点Iを中心として、軸α（O→I方向）と軸β（αをπ/2回転）に対してφ回転</p>
            <p>• 青い点: 原点O, 赤い点: 点I, 緑の正方形: PQRS</p>
            <p>• 青い線: 軸α（O→I方向）, 赤い線: 軸β（αをπ/2回転）</p>
            <p>• 同期モード: θとφを連動させ、比率を設定可能（φ = 比率 × θ）</p>
            <p>• 通過面積: 正方形の軌跡が薄い緑色で表示され、回転による通過面積が可視化されます</p>
            <p>• 軌跡クリア: 「軌跡をクリア」ボタンで通過面積の表示をリセットできます</p>
        </div>
    </div>

    <script>
        class SquareRotationVisualizer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                // パラメータ
                this.r = 1.5;
                this.l = 2.0;
                this.theta = 0;
                this.phi = 0;
                this.syncEnabled = false;
                this.ratio = 1.0;
                
                // 通過面積の軌跡を記録
                this.trajectoryPoints = [];
                this.maxTrajectoryPoints = 1000; // 軌跡の最大点数
                this.showTrajectory = false; // 軌跡表示の状態
                
                this.setupEventListeners();
                this.draw();
            }
            
            setupEventListeners() {
                const sliders = ['r', 'l', 'theta', 'phi', 'ratio'];
                sliders.forEach(id => {
                    const slider = document.getElementById(id);
                    const valueDisplay = document.getElementById(id + '-value');
                    
                    slider.addEventListener('input', (e) => {
                        let value = parseFloat(e.target.value);
                        
                        
                        this[id] = value;
                        
                        // 角度の場合は度数法とラジアン法の両方で表示
                        if (id === 'theta' || id === 'phi') {
                            this.updateAngleDisplay(id, this[id]);
                        } else {
                            valueDisplay.textContent = this[id].toFixed(2);
                        }
                        
                        // 同期モードでθが変更された場合、φを自動計算
                        if (this.syncEnabled && id === 'theta') {
                            this.phi = this.theta * this.ratio;
                            document.getElementById('phi').value = this.phi;
                            this.updateAngleDisplay('phi', this.phi);
                        }
                        
                        // 軌跡を記録（表示が有効な場合のみ）
                        if (this.showTrajectory) {
                            this.recordTrajectory();
                        }
                        
                        this.draw();
                    });
                });
                
                // 同期トグル
                const syncToggle = document.getElementById('sync-toggle');
                const ratioGroup = document.getElementById('ratio-group');
                
                syncToggle.addEventListener('change', (e) => {
                    this.syncEnabled = e.target.checked;
                    ratioGroup.style.display = this.syncEnabled ? 'block' : 'none';
                    
                    if (this.syncEnabled) {
                        // 同期開始時、現在のθに基づいてφを設定
                        this.phi = this.theta * this.ratio;
                        document.getElementById('phi').value = this.phi;
                        const phiDegrees = (this.phi * 180 / Math.PI).toFixed(1);
                        document.getElementById('phi-value').textContent = `${this.phi.toFixed(2)} rad (${phiDegrees}°)`;
                    }
                    
                    this.draw();
                });
                
                // 軌跡表示切り替えボタン
                const toggleButton = document.getElementById('toggle-trajectory');
                toggleButton.addEventListener('click', () => {
                    this.showTrajectory = !this.showTrajectory;
                    toggleButton.textContent = this.showTrajectory ? '軌跡を非表示' : '軌跡を表示';
                    toggleButton.style.backgroundColor = this.showTrajectory ? '#f44336' : '#4caf50';
                    this.draw();
                });
                
                // 軌跡クリアボタン
                const clearButton = document.getElementById('clear-trajectory');
                clearButton.addEventListener('click', () => {
                    this.clearTrajectory();
                    this.draw();
                });
            }
            
            
            // 角度表示を更新する関数
            updateAngleDisplay(id, value) {
                const valueDisplay = document.getElementById(id + '-value');
                const degrees = (value * 180 / Math.PI).toFixed(1);
                valueDisplay.textContent = `${value.toFixed(2)} rad (${degrees}°)`;
            }
            
            // 軌跡を記録する関数
            recordTrajectory() {
                const vertices = this.getSquareVertices();
                const canvasVertices = vertices.map(v => this.toCanvasCoords(v.x, v.y));
                
                // 現在の正方形の頂点を軌跡に追加
                this.trajectoryPoints.push({
                    vertices: canvasVertices,
                    timestamp: Date.now()
                });
                
                // 軌跡の点数を制限
                if (this.trajectoryPoints.length > this.maxTrajectoryPoints) {
                    this.trajectoryPoints.shift();
                }
            }
            
            // 軌跡をクリアする関数
            clearTrajectory() {
                this.trajectoryPoints = [];
            }
            
            // 座標変換: 数学座標系からCanvas座標系へ
            toCanvasCoords(x, y) {
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                const scale = 80; // スケールファクター
                return {
                    x: centerX + x * scale,
                    y: centerY - y * scale // Y軸を反転
                };
            }
            
            // 回転行列
            rotate(x, y, angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return {
                    x: x * cos - y * sin,
                    y: x * sin + y * cos
                };
            }
            
            // 点Iの位置を計算
            getPointI() {
                // 点I(ℓ, 0)をθ回転
                return this.rotate(this.l, 0, this.theta);
            }
            
            // 軸αとβの方向ベクトルを計算
            getAxes() {
                const pointI = this.getPointI();
                const axisAlpha = {
                    x: pointI.x,
                    y: pointI.y
                };
                
                // 軸βは軸αをπ/2回転
                const axisBeta = this.rotate(axisAlpha.x, axisAlpha.y, Math.PI / 2);
                
                return { alpha: axisAlpha, beta: axisBeta };
            }
            
            // 正方形の頂点を計算
            getSquareVertices() {
                const pointI = this.getPointI();
                const axes = this.getAxes();
                
                // 軸αとβを正規化
                const alphaLength = Math.sqrt(axes.alpha.x * axes.alpha.x + axes.alpha.y * axes.alpha.y);
                const betaLength = Math.sqrt(axes.beta.x * axes.beta.x + axes.beta.y * axes.beta.y);
                
                const alphaUnit = {
                    x: axes.alpha.x / alphaLength,
                    y: axes.alpha.y / alphaLength
                };
                const betaUnit = {
                    x: axes.beta.x / betaLength,
                    y: axes.beta.y / betaLength
                };
                
                // 正方形の頂点（軸α, β座標系で）
                const vertices = [
                    { x: this.r, y: 0 },   // P
                    { x: 0, y: -this.r },  // Q
                    { x: -this.r, y: 0 },  // R
                    { x: 0, y: this.r }    // S
                ];
                
                // φ回転を適用
                const rotatedVertices = vertices.map(v => this.rotate(v.x, v.y, this.phi));
                
                // 軸α, β座標系から通常の座標系に変換
                return rotatedVertices.map(v => ({
                    x: pointI.x + v.x * alphaUnit.x + v.y * betaUnit.x,
                    y: pointI.y + v.x * alphaUnit.y + v.y * betaUnit.y
                }));
            }
            
            draw() {
                // キャンバスをクリア
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // 座標軸を描画
                this.drawAxes();
                
                // 軌跡を描画（通過面積）- 表示が有効な場合のみ
                if (this.showTrajectory) {
                    this.drawTrajectory();
                }
                
                // 原点O
                const origin = this.toCanvasCoords(0, 0);
                this.ctx.fillStyle = '#2196f3';
                this.ctx.beginPath();
                this.ctx.arc(origin.x, origin.y, 6, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // 点I
                const pointI = this.getPointI();
                const pointICanvas = this.toCanvasCoords(pointI.x, pointI.y);
                this.ctx.fillStyle = '#f44336';
                this.ctx.beginPath();
                this.ctx.arc(pointICanvas.x, pointICanvas.y, 6, 0, 2 * Math.PI);
                this.ctx.fill();
                this.ctx.fillStyle = '#000';
                this.ctx.fillText('I', pointICanvas.x + 10, pointICanvas.y + 5);
                
                // 軸αとβを描画
                this.drawAxesLines(pointI);
                
                // 正方形を描画
                this.drawSquare();
            }
            
            drawAxes() {
                // X軸
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.height / 2);
                this.ctx.lineTo(this.width - 20, this.height / 2);
                this.ctx.stroke();
                
                // X軸の矢印
                this.drawArrow(this.width - 30, this.height / 2, this.width - 10, this.height / 2, '#333');
                
                // Y軸
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(this.width / 2, 20);
                this.ctx.lineTo(this.width / 2, this.height);
                this.ctx.stroke();
                
                // Y軸の矢印
                this.drawArrow(this.width / 2, 30, this.width / 2, 10, '#333');
                
                // X軸のラベル
                this.ctx.fillStyle = '#333';
                this.ctx.font = '14px Arial';
                this.ctx.fillText('x', this.width - 20, this.height / 2 - 10);
                
                // Y軸のラベル
                this.ctx.fillText('y', this.width / 2 + 10, 20);
                
                // 原点のラベル
                this.ctx.fillText('O', this.width / 2 + 5, this.height / 2 - 5);
            }
            
            drawAxesLines(pointI) {
                const axes = this.getAxes();
                const pointICanvas = this.toCanvasCoords(pointI.x, pointI.y);
                
                // 軸β（αをπ/2回転）の長さを定義
                const axisBetaLength = 0.5; // β軸の長さ（数学座標系での長さ）
                const betaEnd = this.toCanvasCoords(
                    pointI.x + axes.beta.x * axisBetaLength,
                    pointI.y + axes.beta.y * axisBetaLength
                );
                
                // 軸α（O→I方向）をβ軸と同じ長さに調整
                const axisAlphaLength = axisBetaLength; // β軸と同じ長さ
                const alphaEnd = this.toCanvasCoords(
                    pointI.x + axes.alpha.x * axisAlphaLength,
                    pointI.y + axes.alpha.y * axisAlphaLength
                );
                
                // 軸αを描画
                this.ctx.strokeStyle = '#2196f3';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(this.width / 2, this.height / 2);
                this.ctx.lineTo(alphaEnd.x, alphaEnd.y);
                this.ctx.stroke();
                
                // 軸αの矢印を描画
                this.drawArrow(this.width / 2, this.height / 2, alphaEnd.x, alphaEnd.y, '#2196f3');
                
                // 軸βを描画
                this.ctx.strokeStyle = '#f44336';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(pointICanvas.x, pointICanvas.y);
                this.ctx.lineTo(betaEnd.x, betaEnd.y);
                this.ctx.stroke();
                
                // 軸βの矢印を描画
                this.drawArrow(pointICanvas.x, pointICanvas.y, betaEnd.x, betaEnd.y, '#f44336');
                
                // 軸のラベル - より適切な位置に配置
                this.ctx.fillStyle = '#2196f3';
                this.ctx.font = '12px Arial';
                this.ctx.fillText('α', alphaEnd.x + 5, alphaEnd.y - 5);
                
                this.ctx.fillStyle = '#f44336';
                this.ctx.fillText('β', betaEnd.x + 5, betaEnd.y - 5);
            }
            
            // 矢印を描画する関数
            drawArrow(fromX, fromY, toX, toY, color) {
                const headLength = 15; // 矢印の長さ
                const headAngle = Math.PI / 6; // 矢印の角度（30度）
                
                // 矢印の方向ベクトル
                const dx = toX - fromX;
                const dy = toY - fromY;
                const angle = Math.atan2(dy, dx);
                
                // 矢印の先端の座標
                const arrowX1 = toX - headLength * Math.cos(angle - headAngle);
                const arrowY1 = toY - headLength * Math.sin(angle - headAngle);
                const arrowX2 = toX - headLength * Math.cos(angle + headAngle);
                const arrowY2 = toY - headLength * Math.sin(angle + headAngle);
                
                // 矢印を描画
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(toX, toY);
                this.ctx.lineTo(arrowX1, arrowY1);
                this.ctx.moveTo(toX, toY);
                this.ctx.lineTo(arrowX2, arrowY2);
                this.ctx.stroke();
            }
            
            // 軌跡（通過面積）を描画する関数
            drawTrajectory() {
                if (this.trajectoryPoints.length < 2) return;
                
                // 軌跡を薄い色で描画
                this.ctx.fillStyle = 'rgba(76, 175, 80, 0.1)'; // 薄い緑色
                this.ctx.strokeStyle = 'rgba(76, 175, 80, 0.3)'; // 薄い緑色の線
                this.ctx.lineWidth = 1;
                
                // 各時点での正方形の軌跡を描画
                for (let i = 0; i < this.trajectoryPoints.length; i++) {
                    const point = this.trajectoryPoints[i];
                    const vertices = point.vertices;
                    
                    // 正方形の軌跡を描画
                    this.ctx.beginPath();
                    this.ctx.moveTo(vertices[0].x, vertices[0].y);
                    for (let j = 1; j < vertices.length; j++) {
                        this.ctx.lineTo(vertices[j].x, vertices[j].y);
                    }
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();
                }
            }
            
            drawSquare() {
                const vertices = this.getSquareVertices();
                const canvasVertices = vertices.map(v => this.toCanvasCoords(v.x, v.y));
                
                // 正方形を描画
                this.ctx.strokeStyle = '#4caf50';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(canvasVertices[0].x, canvasVertices[0].y);
                for (let i = 1; i < canvasVertices.length; i++) {
                    this.ctx.lineTo(canvasVertices[i].x, canvasVertices[i].y);
                }
                this.ctx.closePath();
                this.ctx.stroke();
                
                // 頂点を描画
                const labels = ['P', 'Q', 'R', 'S'];
                canvasVertices.forEach((vertex, index) => {
                    this.ctx.fillStyle = '#4caf50';
                    this.ctx.beginPath();
                    this.ctx.arc(vertex.x, vertex.y, 4, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#000';
                    this.ctx.font = '12px Arial';
                    this.ctx.fillText(labels[index], vertex.x + 8, vertex.y + 5);
                });
            }
        }
        
        // ページ読み込み時に初期化
        window.addEventListener('load', () => {
            new SquareRotationVisualizer();
        });
    </script>
</body>
</html>
